# 希尔排序
- 简述
	- 希尔排序又称之为缩小增量排序，从思维导图（冒泡排序的博客）可以得知，这也是一种插入排序，事实上，它就是直接插入排序的加强优化版本。
- 过程描述
	- 下面的叙述按照维基百科的例子来解释，有一个数据序列为[13, 14, 94, 33, 82, 25, 59, 94, 65, 23, 45, 27, 73, 25, 39, 10]。
	- 首先，设定一个步长5，进行排序。
		- 此时序列为4行5列：
		- [13, 14, 94, 33, 82,<br>&nbsp;25, 59, 94, 65, 23, <br>&nbsp;45, 27, 73, 25, 39, <br> &nbsp;10]
		- 对**每一列**进行排序。
		- [10, 14, 73, 25, 23,<br>&nbsp;13, 27, 94, 33, 39, <br>&nbsp;25, 59, 94, 65, 82, <br> &nbsp;45]
		- 排序后序列为[10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45]
	- 接着，再以3为步长进行排序。
		- 此时序列为5行3列：
		- [10, 14, 73,<br>&nbsp;25, 23, 13, <br>&nbsp;27, 94, 33, <br>&nbsp;39, 25, 59, <br>&nbsp;94, 65, 82, <br>&nbsp;45]
		- 对**每一列**进行排序。
		- [10, 14, 13,<br>&nbsp;25, 23, 33, <br>&nbsp;27, 25, 59, <br>&nbsp;39, 65, 73, <br>&nbsp;45, 94, 82, <br>&nbsp;94]
	- 最后，以1为步长进行排序，此时就是一个直接插入排序了。
	- 不难发现，步长的选择是希尔排序的重要部分，Donald Shell（算法提出者）建议使用**序列长度的一半作为初始步长（也就是N/2)**并不断取半直到到达1，尽管还有优化的余地，这里就不介绍了。
	- 算法最开始以一定的步长进行排序，然后会继续以更小的步长进行排序，最终算法一定是以步长为1进行排序。当步长为 1 时，算法变为直接插入排序，这就保证了数据一定会被全部排序。
- 复杂度

				| 排序名称 | 最好情况 | 最坏情况 | 平均情况 |
				| :---: | :---: | :---: | :---: |
				| 希尔排序 |  | O(n^2) | O(nlogn) |
- 特点
	- 希尔排序有效减少了排序的趟数，因为不断使得序列基本有序，在上一篇直接插入排序中我提到，序列本身越是有序，排序效率越高，经过之前的步长处理，最后一趟直接插入排序是很高效的。
	- 希尔排序低步长排序结果在高步长状态下依然有序。
	- 步长序列的不同直接导致了算法复杂度变化。
	- 希尔排序相同数据有可能交换位置，是不稳定的，之前的直接插入是稳定的。同时，直接插入对链式存储数据也合适，但是，由于二维数据变换，希尔排序是不能的。
		