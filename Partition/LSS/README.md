# 连续子序列的最大和
- 前言
	- 分治算法的核心思想是将一个规模很大的问题化简为n个规模较小的问题，这些子问题虽然独立而不同，但是问题的本质是一致的，从而达到分而治之的目的。
	- 首先通过“分”将问题分解为n个子问题，再将子问题一步步分解，知道达到最小的子问题。这时，“治”子问题再利用子问题的解推导总问题的解。
	- 子问题应与原问题拥有同样的结构，或者拥有同样的形式。只有这样，才能利用递归解决子问题。
- 问题描述
	- 给定一个列表数据，其中数据可正可负，找出和最大的子列表的和，子列表不能为空。
- 问题分析
	- 这类题其实用DP也是一种解题思路，当然也是分治的经典问题。
	- 看一个例子，输入列表如下。
		- [-2, 1, -3, 4, -1, 2, 1, -5, 4]
		- 按照分治的思路，最大子列表有可能在左子列表、右子列表或左子列表和右子列表之间。我们需要做的就是找到左子列表的最大子列表的和、右子列表的最大子列表的和、左子列表与右子列表之间的子列表的最大和，再进行比较。
		- 如何找到左子列表与右子列表的最大子列表的和呢？分治的想法是：让左左子列表与右子列表的子列表回答这个问题就好了，此时此刻不需要知道答案，只需要知道答案有三种可能。
		- 现在需要做的是找到第三种可能，也就是左子列表与右子列表之间的子列表的最大和。设一个中点，遍历中点左边的值，跟踪记录已经遍历过的值的总和，取这些总和的最大值；同样的方法遍历中点右边的值。最后，左边的最大值加上右边的最大值加上中点值就是想要的值。
		- 那么如何找第一种可能，也就是左子列表的最大和。其实，对待左子列表的方式和对待列表一样，还是有三个可能，第一个与第二个不关心，第三个按照上面的做法寻找。
		- 如何找到第二种可能与上面一致。
		- 按照这个一步步分解的思路，其实，最后左右子列表都各有一个值，结果为三种可能最大的。最终，根据子问题推到了大问题的三种可能值，最终得到答案。
- 代码
	- ```python
		# -*-coding:utf-8-*-
		def LSS(array):
		
		    if array == []:
		        return
		
		    if len(array) == 1:
		        return array[0]
		
		    cut = len(array) // 2  # 设置中点
		    left_sum = LSS(array[: cut])
		    right_sum = LSS(array[cut:])
		
		    # 从中点开始分别左右遍历查值
		
		    left_middle_sum = 0
		    max_l = 0
		    right_middle_sum = 0
		    max_r = 0
		    for i in range(cut-1, -1, -1):
		        left_middle_sum += array[i]
		        max_l = max(left_middle_sum, max_l)
		    for j in range(cut+1, len(array), 1):
		        right_middle_sum += array[j]
		        max_r = max(right_middle_sum, max_r)
		
		    return max(left_sum, right_sum, max_l+max_r+array[cut])
		
		
		if __name__ == '__main__':
		    array = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
		    rst = LSS(array)
		    print(rst)
		```
- 运行结果
	- ![](https://img-blog.csdnimg.cn/20190418125306524.png)
- 补充说明
	- 具体代码可以查看我的Github，欢迎Star或者Fork
	- 参考书《你也能看得懂的Python算法书